/*
문제 출처 : https://www.acmicpc.net/problem/2590 (백준 온라인 저지)

정사각형 모양을 한 여섯 종류의 색종이가 있다. 
1번 색종이는 한 변의 길이가 1cm이고 차례대로 그 길이가 1cm씩 커져 6번 색종이의 한 변의 길이는 6cm가 된다.
주어진 색종이를 가로, 세로의 길이가 각각 6cm인 판 위에 붙이려고 한다. 
색종이를 붙일 때는 색종이가 판의 경계 밖으로 삐져 나가서는 안 되며, 색종이가 서로 겹쳐서도 안 된다. 
각 종류별로 색종이의 장수가 주어질 때, 그 색종이를 모두 붙이기 위해서 위와 같은 판이 최소 몇 개가 필요한지 구하는 문제.

코드가 너무 복잡해지는 거 같아서 다른 풀이를 찾아보았는데 별다른 알고리즘 없이 구현만으로 푸는 문제였다.
크기가 작은 색종이일 수록 크기가 큰 색종이를 붙이고 남은 빈 칸에 추가적으로 붙여줄 수 있으므로
크기가 큰 색종이들부터 판에 붙이는 걸 구현한 뒤 남은 칸에 작은 색종이들을 추가로 최대한 붙여주는 방식으로 구현했다.

시간복잡도는 코드에 존재하는 반복문이 상수 번밖에 돌지 않으므로 O(1)
*/

#include <iostream>
#include <algorithm>
using namespace std;

int arr[7];

int main() {
	int pan = 0, empty;

	for (int i = 1; i <= 6; i++) {
		cin >> arr[i];
	}

	// 6번 색종이 처리
	pan += arr[6]; // 6번 색종이는 한 장에 한 판이 다 차므로 색종이의 장수가 그대로 필요한 판의 개수가 된다.

	// 5번 색종이 처리
	pan += arr[5]; // 5번 색종이도 한 판에 한 장만 붙일 수 있으므로 무조건 색종이 장수만큼의 판이 필요하다.
	arr[1] = max(0, arr[1] - 11 * arr[5]); // 5번 색종이를 붙이면 11칸이 남는데, 이 남는 칸에 1번 색종이들을 추가로 붙일 수 있다.

	// 4번 색종이 처리
	pan += arr[4]; // 4번 색종이도 한 판에 한 장만 붙일 수 있으므로 무조건 색종이 장수만큼의 판이 필요하다.
	// 4번 색종이는 한 판에 색종이를 붙이고 남는 20개의 칸에 2번 색종이와 1번 색종이를 추가로 붙일 수 있다.
	// 먼저 크기가 더 큰 2번 색종이를 추가로 붙이는 과정을 구현해준다.
	// 2번 색종이는 20개의 남는 칸에 최대 5개까지 붙일 수 있다.
	if (arr[2] > (5 * arr[4])) // arr[4]개의 모든 판들에 대해, 4번 색종이를 붙이고 남은 칸에다 2번 색종이를 5개씩 꽉 차게 붙이는 경우
		arr[2] -= (5 * arr[4]);
	else { 
		// 4번 색종이를 붙이고 남은 칸에 2번 색종이들을 최대한 붙이고 나서도 칸이 남는 경우, 남는 칸의 개수(empty)를 구한다.
		empty = (arr[4] - arr[2] / 5) * 20; 
		empty -= (arr[2] % 5) * 4;
		arr[2] = 0;

		arr[1] = max(0, arr[1] - empty); // 남는 칸에는 1번 색종이들을 붙여준다.
	}

	// 3번 색종이 처리
	pan += arr[3] / 4; // 3번 색종이는 한 판에 최대 4개 붙일 수 있다.
	arr[3] %= 4;

	if (arr[3]) {
		pan++;
		empty = 36 - (arr[3] * 9);

		// 남은 칸이 4개 있어도 4개의 칸들이 서로 정사각형 형태가 아니면 2번 색종이를 붙일 수 없다.
		// 그런 경우에는 1번 색종이를 4개 붙여줘야 한다.
		int bound; 
		if (arr[3] == 1) // 붙여야될 3번 색종이가 1개면, 3번 색종이를 붙이고 남은 칸들의 형태 상 27개의 남은 칸에 2번 색종이를 최대 5개 붙여줄 수 있다.
			bound = 7; // 그러면 남은 칸은 27 - 5 * 4 = 7
		else if (arr[3] == 2)
			bound = 6;
		else
			bound = 5;

		while (empty > bound && arr[2] > 0) {
			arr[2]--;
			empty -= 4;
		}

		arr[1] = max(0, arr[1] - empty); // 남은 칸에 1번 색종이를 붙여준다.
	}


	// 2번 색종이 처리
	pan += arr[2] / 9;
	arr[2] %= 9;
	
	if (arr[2]) {
		pan++;
		empty = 36 - arr[2] * 4;
		arr[1] = max(0, arr[1] - empty); // 남은 칸에 1번 색종이를 붙여준다.
	}

	// 1번 색종이 처리
	pan += arr[1] / 36;
	if (arr[1] % 36)
		pan++;

	cout << pan;

	return 0;
}
