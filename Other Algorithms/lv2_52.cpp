/*
문제 출처 : https://programmers.co.kr/learn/courses/30/lessons/84512 (프로그래머스 Level 2)

사전에 알파벳 모음 'A', 'E', 'I', 'O', 'U'만을 사용하여 만들 수 있는 길이 5 이하의 모든 단어가 수록되어 있다.
사전에서 첫 번째 단어는 "A"이고, 그다음은 "AA"이며, 마지막 단어는 "UUUUU"이다.
단어 하나가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째인지 리턴하는 문제.

각 자리의 문자 별로 사전에서 내 앞에 몇 개의 단어가 있는지를 계산하면 빠르게 풀 수 있다.
알파벳 모음이 총 5개이므로 자리 별로 5의 제곱수를 이용하여 앞에 내 몇 개의 단어가 있는지 계산한다.
"EEEEO"를 기준으로 예를 들면
5번째 자리에서 알파벳 O보다 앞서는 알파벳은 A, E, I 3개이다.
5번째 자리는 마지막 자리이므로 더 고려해야 할 뒷자리의 문자열들이 없으니 3 * 5^0 = 3개의 문자열이 사전상 "O" 앞에 있다.
4번째 자리의 경우 E보다 앞서는 알파벳은 A 1개지만
뒤의 5번째 자리에 올 수 있는 문자들도 고려해야 한다.
사전 순이라 "AA", "AE", "AI", "AO", "AU", 그리고 "A"까지 모두 "E_"보다 작기 때문이다. 
(여기서 _는 AEIOU 중 하나로 무엇이 오든 위의 6개의 문자열들 보다는 순서상 뒤에 위치한다.)
따라서 1 * (5^1 + 5^0) = 6개의 문자열이 "EX"보다 사전상 앞에 올 수 있으며
"EO"는 (1 * (5^1 + 5^0)) + (3 * 5^0) = 9개의 문자열들이 자신보다 앞에 위치한다.
같은 식으로 3번째 자리에 적용하면 1 * (5^2 + 5^1 + 5^0)개의 문자열이 "E__"보다 앞에 위치한다.
즉, 1번째 자리는 5^0 + ...  + 5^4 = 781
2번째 자리는 5^0 + ... + 5^3 = 156
3번째 자리는 5^0 + ... + 5^2 = 31
4번째 자리는 5^0 + ... + 5^1 = 6
5번째 자리는 5^0 = 1
을 각각 해당 자리의 알파벳보다 순서상 앞인 알파벳 모음의 개수와 곱해주면 된다.
마지막에 1을 더하는 이유는 자신보다 앞에 있는 문자열의 개수가 n이면 자신의 순서는 n + 1이기 때문이다.

시간복잡도는 O(n)
*/

#include <string>
#include <vector>

using namespace std;

int solution(string word) {
    int answer = 0;
    vector<int> v = {781, 156, 31, 6, 1};
    
    for (int i = 0; i < word.length(); i++) {
        string s = "AEIOU";
        answer += s.find(word[i]) * v[i] + 1;
    }
    
    return answer;
}
