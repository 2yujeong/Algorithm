/*
문제 출처 : https://www.acmicpc.net/problem/2437 (백준 온라인 저지)

한쪽에는 저울추만, 다른 한쪽에는 무게를 측정하려는 물건만 올려놓을 수 있는 양팔 저울이 있다.
이 양팔저울을 이용하여 무게를 측정하려고 한다.
무게가 양의 정수인 N개의 저울추가 주어질 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값을 구하는 문제.

처음에는 DFS를 이용하여 조합탐색으로 풀려고 했다.
주어진 추들로 만들 수 있는 모든 무게의 합의 조합을 구해 배열에 넣고, 배열에 존재하지 않는 양의 정수 중 최솟값을 출력했는데 메모리 초과로 통과하지 못했다.
이 문제는 조합탐색이 아닌 누적합을 이용하여 그리디 알고리즘으로 풀어야 한다.
우선 입력 받은 추의 무게들을 오름차순으로 정렬한다.
만약 (0번부터 i번까지의 추의 무게들의 합(=누적합) + 1)이 i + 1번째 추의 무게와 같거나 크다면
1부터 (누적합 + 1)까지의 양수들은 모두 기존에 입력받은 추들의 무게의 조합으로 표현할 수 있다.
반대로 (누적합 + 1)보다 i + 1번째 무게가 더 크다면 이 (누적합 + 1) 값은 기존 추들의 무게의 조합으로 표현할 수 없으므로 정답으로 출력해준다.

시간복잡도는 O(nlog n)
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	int n;
	cin >> n;

	vector<int> weights(n);

	for (int i = 0; i < n; i++) {
		cin >> weights[i];
	}

	sort(weights.begin(), weights.end());

	int sum = 1; // 초기에 누적합에 1을 더해준다.
	for (int i = 0; i < n; i++) {
		if (sum < weights[i]) // 0 ~ (i - 1)까지의 무게의 누적합 + 1이 i번째 무게보다 작다면 그 수는 기존 추들의 무게의 조합으로 표현 불가능
			break;

		sum += weights[i]; // 0번부터 i번까지의 무게들의 누적합. 위에서 초기화 시 1을 이미 더해줬으므로 정확히는 항상 누적합 + 1 값이 저장된다.
	}

	cout << sum;

	return 0;
}
