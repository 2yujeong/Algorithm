/*
문제 출처 : https://programmers.co.kr/learn/courses/30/lessons/77885 (프로그래머스 Level 2)

양의 정수 x에 대한 f(x)를 x보다 크고 x와 비트가 2개 이하로 다른 수들 중에서 제일 작은 수로 정의한다. 
주어진 정수 배열 numbers의 모든 수들에 대하여 각 수의 f값을 리턴하는 문제.

처음엔 n부터 1씩 증가시킨 수들에 대해 일일이 2진수로 변환해가며 n과 비트를 비교하는 방식으로 풀었더니 시간초과가 떴다.
의외로 규칙을 찾으면 어렵지 않게 풀 수 있는 문제였다.
1) n이 짝수인 경우
2진수의 경우 맨 오른쪽 비트로 짝수 홀수를 구분할 수 있다.
맨 오른쪽 비트가 1이고 나머지 비트들은 모두 2^n이기 때문에 맨 오른쪽 비트가 1이면 홀수, 0이면 짝수가 된다.
따라서 n이 짝수인 경우 1만 더하면 맨 오른쪽 비트 하나만 0에서 1이 되고 그 값은 n + 1이 되므로 
비트가 하나만 바뀌면서 n보다 큰 수 중 가장 작은 수인 f의 조건을 만족한다.
2) n이 홀수인 경우
맨 오른쪽 비트가 1인 경우 1을 더하면 올림 때문에 왼쪽 비트들에 영향을 주게 된다.
0에서 1로 바뀌는 비트가 나올 때까지 왼쪽으로 계속 올림하게 되는데 예를 들어 110111의 경우 1을 더하면 111000이 된다. 
이때 비트가 2개가 넘게 바뀌지 않고 최대한 작은 수를 찾으려면 가장 오른쪽에 위치한 0의 바로 오른쪽 비트에 1을 더해주면 된다.
110111의 경우 2^3자리의 비트, 즉 왼쪽에서 3번째 비트가 0이므로 4번째 비트에 1을 더해주면 111011로 이 값이 f가 된다.
(110111 + 000100 = 111011)
0에서 1로 바꿔줌으로써 원래의 n보다 큰 수가 되고, 그 아래 자리의 비트들 중 가장 값이 큰 2^2자리를 0으로 바꿔줌으로써 n보다는 큰 수들 중 비트 2개를 바꿈으로써 얻을 수 있는 가장 작은 수를 얻은 것이다.

시간복잡도는 최악의 경우 n을 2진수로 표현했을 때의 모든 자리의 비트들을 다 탐색하게 되므로 O(mlog (n + 1)), m은 numbers 배열의 크기
*/

#include <string>
#include <vector>
#include <iostream>

using namespace std;

vector<long long> solution(vector<long long> numbers) {
    vector<long long> answer;
    
    for (long long n : numbers) {
        if (n % 2 == 0) // 짝수인 경우
            answer.push_back(n + 1); // 맨 오른쪽 비트만 1로 바꿔준다.
        else { // 홀수인 경우
            long long flag = 1;
            
            // 가장 오른쪽에 위치한 비트 0의 자리 찾기
            while ((n & flag) != 0) { // flag는 i번째 비트 외에는 다 0이므로 n의 i번째 비트가 0이어야 & 연산 결과가 0이 된다.
                flag *= 2; // 비트 1을 왼쪽으로 한 칸씩 옮겨준다. (1 -> 10 -> 100 -> ...)
            }
            flag /= 2; // 비트 0의 자리를 찾았다면 그 바로 오른쪽에 자리한 비트에 1을 더해줘야 하므로 비트 1을 다시 오른쪽으로 한 칸 옮긴다.
            
            answer.push_back(n + flag);
        }
    }
    
    return answer;
}
