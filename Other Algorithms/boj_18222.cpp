/*
문제 출처 : https://www.acmicpc.net/problem/18222 (백준 온라인 저지)

투에-모스 문자열은 "0"에서 시작하여 기존 문자열의 bool 보수(0은 1로, 1은 0으로)를 뒤에 계속 붙여나가는 문자열을 뜻한다.
즉 처음에 "0"으로 시작하여 "01"이 되고, "0110"이 되고, "01101001"이 되고, ⋯ 의 과정을 거친다.
투에-모스 문자열의 k번째에 오는 문자가 무엇인지 구하는 문제.

k길이 만큼의 문자열을 직접 생성해주는 방식으로는 메모리 초과가 나기 때문에 점화식을 찾아야 한다.
길이가 8인 투에-모스 문자열 "01101001"을 생각해보면
7번째 문자를 찾는다고 할 때, 우선 7보다 작은 2의 거듭제곱 중 가장 큰 수를 생각한다.
그 수는 4이고 길이가 4인 문자열은 "0110"이다. 
이제 이 문자열에 3개의 문자들만 뒤에 더 붙여주면 7번째 문자를 알 수 있는데
투에-모스 문자열은 이전 문자열의 bool 보수가 뒤에 이어붙여지는 형식이므로 "0110"의 3번째 문자인 1의 bool 보수인 0이 7번째 문자가 된다. 
즉, n보다 작은 2의 거듭제곱 중 가장 큰 수를 m이라고 할 때, n번째 수는 (n - m)번째 수의 bool 보수와 같다는 것을 알 수 있다.
이를 식으로 표현하면 f(n) = !f(n - m)이 된다.

시간복잡도는 O(log k)
*/

#include <iostream>
#include <string>
using namespace std;

int recursion(long long k, long long i) {
	if (k == 1)
		return 0;
	if (k == 2)
		return 1;

	while (i >= k) {
		i /= 2;
	}

	return !recursion(k - i, i);
}

int main() {
	long long k, i = 1;
	cin >> k;

	while (i * 2 < k) {
		i *= 2;
	}

	cout << recursion(k, i);
}
