/*
문제 출처 : https://www.acmicpc.net/problem/2212 (백준 온라인 저지)

평면상의 직선 형태인 고속도로에 N개의 센서와 최대 K개의 집중국을 설치하려고 한다.
모든 센서들은 적어도 하나의 집중국과는 통신이 가능해야 하며
집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.
각 센서의 위치(평면상의 정수 좌표)와 N, K가 주어질 때, 각 집중국의 수신 가능 영역의 거리의 합의 최솟값을 구하는 문제.

처음에는 문제에서 주어진 입출력 예제가 머릿속에 잘 그려지지 않아서 일단 문제를 간단하게 정리해봤다.
3개의 센서가 있는 고속도로에 최대 2개의 집중국을 설치할 수 있는 경우를 예로 들면,
1, 2, 3번 센서가 각각 좌표상 5, 7, 14 위치에 설치되어 있다고 할 때 집중국 2개는 다음과 같이 설치할 수 있다
 1) 집중국 하나는 좌표상 5 ~ 7 사이에 설치되어 1번 센서와 2번 센서를 커버하고 나머지 하나는 14 위치에 설치되어 3번 센서를 커버한다.
 2) 집중국 하나는 좌표상 5 위치에 설치되어 1번 센서를 커버하고 나머지 하나는 7 ~ 14 사이에 설치되어 2번, 3번 센서를 커버한다.
1번의 경우 1, 2번 센서를 커버하기 위한 집중국이 2만큼의 수신 가능 영역을 갖고 
3번 센서를 커버하기 위한 집중국이 0만큼의 수신 가능 영역을 가져 총 2만큼의 수신 가능 영역이 나온다.
2번의 경우 1번 센서를 커버하기 위한 집중국이 0만큼의 수신 가능 영역을 갖고
2, 3번 센서를 커버하기 위한 집중국이 7만큼의 수신 가능 영역을 가져 총 7만큼의 수신 가능 영역이 나온다.
따라서 가능한 각 집중국의 수신 가능 영역의 거리의 합의 최솟값은 2가 된다.

이를 구현하기 위해선 인접한 센서들 간의 거리의 차를 모두 구하고, 이를 정렬하여 서로 떨어져있는 거리가 가장 먼 K개의 경우를 구한다.
센서 1과 2가 너무 멀리 떨어져있다면 이들 사이는 하나의 집중국으로 커버하지 않고 2개의 집중국을 세워 커버한다고 생각하면 된다.
즉 인접한 센서 간 서로 너무 멀리 떨어져 있어서 수신 가능 영역이 커질 수 밖에 없는 K개의 경우는 
K개의 집중국을 세움으로써 포함되어야 하는 수신 가능 영역에서 제외시킬 수 있다.

시간복잡도는 O(nlog n)
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	int n, k;
	cin >> n >> k;

	vector<int> v(n); // 센서들의 위치 저장
	
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}

	sort(v.begin(), v.end()); // 원점과 가장 가까운 센서부터 멀리 있는 순으로 정렬

	for (int i = 0; i < n - 1; i++) { // 인접한 센서들 간 거리의 차를 구한다.
		v[i] = v[i + 1] - v[i];
	}

	v.pop_back();
	sort(v.begin(), v.end()); // 거리의 차를 기준으로 정렬

	int sum = 0;
	for (int i = 0; i < n - k; i++) {
		sum += v[i];
	}

	cout << sum;

	return 0;
}
