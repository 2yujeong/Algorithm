/*
문제 출처 : https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98# (인프런, 알고리즘 문제풀이 강의)

N x N 계곡의 돌다리 격자정보가 주어진다. 돌다리 격자정보는 각 돌다리를 건널 때 소비되는 에너지의 양을 의미한다. 
(1, 1)에서 (N, N)까지 가는 데 드는 에너지의 최소량을 구하는 문제.
이때 이동은 최단거리 이동을 한다. 즉, 현재 지점에서 오른쪽 또는 아래에 있는 돌다리로만 이동할 수 있다.

[dp 테이블 설계]
dp[i][j]는 (0, 0) 돌다리에서 (i, j) 돌다리까지 갈 때 소비되는 에너지의 최소량을 의미한다.
'현재 지점에서 오른쪽 또는 아래에 있는 돌다리로만 이동할 수 있다.'는 조건에 따라 다음과 같은 dp 테이블 설계 규칙을 세울 수 있다. 
- 현재 지점에서 오른쪽 또는 아래에 있는 돌다리로만 이동할 수 있다. -> 특정 돌다리에 도달하려면 해당 돌다리의 왼쪽에 있는 돌다리를 거쳐오거나 위쪽에 있는 돌다리를 거쳐 오는 수밖에 없다. -> (i, j) 돌다리를 밟을 수 있는 경로는 (i - 1, j) 돌다리를 거쳐오는 경로나 (i, j - 1) 돌다리를 거쳐 오는 경로밖에 없다.
- 0행의 경우 위쪽 돌다리가 존재하지 않으므로 무조건 왼쪽 돌다리를 거쳐오는 경로밖에 없다. -> dp[0][j] = dp[0][j - 1] + (해당 돌다리를 밟을 때의 에너지 소비량)
- 0열의 경우에도 왼쪽 돌다리가 존재하지 않으므로 무조건 위쪽 돌다리를 거쳐오는 경로밖에 없다. -> dp[i][0] = dp[i - 1][0] + (해당 돌다리를 밟을 때의 에너지 소비량)
- 0행, 0열을 제외한 i행, j열의 경우 자신의 왼쪽 돌다리와 위쪽 돌다리의 dp 값을 비교하여 두 경로 중 소비되는 에너지의 총량이 더 적은 돌다리의 경로를 선택한다. -> dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + (해당 돌다리를 밟을 때의 에너지 소비량) 

시간복잡도는 O(n^2)
*/

#include <iostream>
#include <algorithm>

using namespace std;

int dp[21][21];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	int n;
	cin >> n;

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			int a;
			cin >> a;

			if (i > 0 && j > 0)
				dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + a;
			else if (i > 0)
				dp[i][j] = dp[i - 1][j] + a;
			else if (j > 0)
				dp[i][j] = dp[i][j - 1] + a;
			else
				dp[i][j] = a;
		}
	}

	cout << dp[n - 1][n - 1];

	return 0;
}
