/*
문제 출처 : https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98# (인프런, 알고리즘 문제풀이 강의)

N개의 문제에 대해 각 문제를 풀었을 때 얻는 점수와 푸는 데 걸리는 시간이 주어진다. 
M시간 안에 N개의 문제를 풀어야 할 때 받을 수 있는 최대점수를 구하는 문제. 이때 하나의 문제는 딱 한 번만 풀 수 있다.

dp_9번(주소)의 경우 같은 보석을 여러 개 넣을 수 있으므로 보석 i(w, v)에 대해 dp를 업데이트 할 때 
dp[j - w]가 이미 보석 i가 하나 이상 포함되어 있는 가치라도 상관없이 dp[j - w] + v > dp[j]라면 가방에 보석 i를 또 넣을 수 있었다.
하지만 이 문제는 그런 식으로 테이블을 설계하면 한 문제를 여러 번 풀어서 최대점수를 얻는 경우가 나올 수 있다.
(예를 들어 dp[j] = 제한시간이 j일 때 받을 수 있는 최대점수라고 하자.
3초가 걸리는 5점짜리 문제A에 대해 dp[4] = dp[4] < dp[1] + 5인 경우 dp[4]가 문제A의 점수를 포함한 최대점수로 초기화된다.
그런데 그 뒤에 dp[7] = dp[7] < do[4] + 5인 경우가 발생하면 dp[7]은 문제A를 두 번 풀음으로써 얻은 최대점수로 초기화되어 버린다.)
따라서 하나의 문제는 한 번만 풀 수 있다는 제약조건을 지키기 위해선 다른 식의 DP 테이블 설계가 필요하다.

1. 2차원 배열 이용
dp[i][j] = 제한시간이 j일 때 1번부터 i번까지의 문제들을 이용하여 받을 수 있는 최대점수
-> i번째 문제를 아직 고려하지 않은 dp 테이블(dp[i - 1][j])에 대해 i번째 문제를 풀음으로써 얻을 수 있는 점수가 더 높은지를 판별해야 한다.

2. 1차원 배열을 이용한 다른 방식 - dp 배열의 뒤에서부터 진행 
dp[j] = 제한시간이 j일 때 받을 수 있는 최대점수
dp 배열 업데이트를 dp[0]부터가 아닌 dp[m]부터 앞으로 진행하면 중복을 방지할 수 있다.

1번 방식의 경우 2차원 배열을 이용하므로 메모리가 초과날 가능성이 높다. 따라서 2번 방식을 더 추천하며 이 문제도 2번 방식으로 풀었다.

시간복잡도는 O(nm)
*/

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	int n, m;
	cin >> n >> m;

	vector<int> dp(m + 1, 0);

	for (int i = 0; i < n; i++) {
		int score, time;
		cin >> score >> time;

		for (int j = m; j >= time; j--) { // 음수 인덱스를 탐색하면 안 되므로 j >= time까지만 탐색
			dp[j] = max(dp[j - time] + score, dp[j]);
		}
	}

	cout << dp[m];

	return 0;
}
